<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cross Platform TTS with Highlight</title>
  <style>
    body {
      background:#0f1226;
      color:#fff;
      font-family:Arial, sans-serif;
      padding:20px;
    }
    #textDisplay span.active {
      background:yellow;
      color:#000;
    }
    #startOverlay {
      position:fixed;
      top:0;left:0;width:100%;height:100%;
      background:rgba(15,18,38,0.9);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:9999;
    }
    #startOverlay button {
      padding:18px 26px;
      font-size:20px;
      border-radius:14px;
      border:none;
      cursor:pointer;
      background:linear-gradient(90deg, #7c5cff, #9a7cff);
      color:#fff;
      font-weight:700;
    }
  </style>
</head>
<body>

  <h2>Cross Platform Text-to-Speech</h2>
  <div id="textDisplay"></div>
  <br/>
  <button onclick="playOrResume()">Play</button>
  <button onclick="pause()">Pause</button>
  <button onclick="stop()">Stop</button>

  <script>
    const synth = window.speechSynthesis;
    let voices = [];
    let currentUtterance = null;
    let wordSpans = [];
    let fallbackTimer = null;
    let currentWordIndex = 0;
    let usingBoundaryEvents = false;

    const textDisplay = document.getElementById("textDisplay");
    const text = "Hello! This is a test for cross platform text to speech with word highlighting on both desktop and mobile devices.";

    // split into spans
    function prepareText(t){
      textDisplay.innerHTML = "";
      wordSpans = t.split(" ").map(word=>{
        const span = document.createElement("span");
        span.textContent = word+" ";
        textDisplay.appendChild(span);
        return span;
      });
    }
    prepareText(text);

    function clearHighlights(){
      wordSpans.forEach(s=>s.classList.remove("active"));
    }

    function highlightIndex(i){
      clearHighlights();
      if(wordSpans[i]) wordSpans[i].classList.add("active");
    }

    function highlightByCharIndex(charIndex){
      let count = 0;
      for(let i=0;i<wordSpans.length;i++){
        count += wordSpans[i].textContent.length;
        if(charIndex < count){
          highlightIndex(i);
          currentWordIndex = i+1;
          break;
        }
      }
    }

    function loadVoices(){
      voices = synth.getVoices();
    }
    loadVoices();
    if(speechSynthesis.onvoiceschanged!==undefined){
      speechSynthesis.onvoiceschanged=loadVoices;
    }

    // ---- Fallback timer (mobile highlight) ----
    function startFallbackTimer(){
      stopFallbackTimer();
      const rate = 1; // if you have rate control, replace here
      // baseline 3.8 words/sec, reduce 25% speed
      const baseWordsPerSec = 3.8 * rate * 0.75;
      const intervalMs = Math.max(90, Math.round(1000 / baseWordsPerSec));

      fallbackTimer = setInterval(()=>{
        if(!synth.speaking || synth.paused) return;
        if(usingBoundaryEvents){ stopFallbackTimer(); return; }

        if(currentWordIndex < wordSpans.length){
          highlightIndex(currentWordIndex);
          currentWordIndex++;
        } else {
          stopFallbackTimer();
        }
      }, intervalMs);
    }

    function stopFallbackTimer(){
      if(fallbackTimer){
        clearInterval(fallbackTimer);
        fallbackTimer = null;
      }
    }

    // ---- Speech control ----
    function speak(){
      if(synth.speaking){ synth.cancel(); }
      clearHighlights();
      stopFallbackTimer();
      currentWordIndex = 0;
      usingBoundaryEvents = false;

      const utter = new SpeechSynthesisUtterance(text);
      currentUtterance = utter;

      if(voices.length>0) utter.voice = voices.find(v=>v.lang.startsWith("en")) || voices[0];
      utter.lang = utter.voice ? utter.voice.lang : "en-US";

      utter.onstart = ()=>{
        // Always start fallback for mobile
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
          startFallbackTimer();
        }
      };

      utter.onend = ()=>{
        clearHighlights();
        stopFallbackTimer();
      };

      utter.onerror = ()=>{
        clearHighlights();
        stopFallbackTimer();
      };

      // Desktop browsers: real highlight
      utter.onboundary = (event)=>{
        if(event.name==="word" || event.charIndex!==undefined){
          usingBoundaryEvents = true;
          highlightByCharIndex(event.charIndex||0);
        }
      };

      synth.speak(utter);
    }

    function playOrResume(){
      if(synth.paused){
        synth.resume();  // resume if paused
      } else if(!synth.speaking){
        speak();        // start fresh if nothing speaking
      }
    }

    function pause(){
      if(synth.speaking && !synth.paused){
        synth.pause();
      }
    }

    function stop(){
      synth.cancel();
      clearHighlights();
      stopFallbackTimer();
    }

    // Autoplay attempt
    function tryAutoplay(){
      setTimeout(()=>{
        speak();
        setTimeout(()=>{
          if(!synth.speaking){
            showStartOverlay();
          }
        },1500);
      },800);
    }

    function showStartOverlay(){
      if(document.getElementById("startOverlay")) return;
      const overlay=document.createElement("div");
      overlay.id="startOverlay";
      const btn=document.createElement("button");
      btn.textContent="ðŸ”Š Tap to Listen";
      btn.onclick=()=>{
        overlay.remove();
        speak();
      };
      overlay.appendChild(btn);
      document.body.appendChild(overlay);
    }

    window.addEventListener("load", tryAutoplay);
  </script>

</body>
</html>
